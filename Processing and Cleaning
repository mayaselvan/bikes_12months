/* Step 3: Process */

##### PRE-CLEANING #####

# 1. Remove invalid values in 'ride_length' column of '202411' table.

-- a. Sort 'ride_length' column to view unexpected values
SELECT *
FROM cyclistic-24-25.cyclistic_dataset.202411
ORDER BY ride_length ASC;
-- Returns 43 records with invalid ##### values

-- b. Verify that invalid values are due to the start time being after end time
SELECT * 
FROM cyclistic-24-25.cyclistic_dataset.202411
WHERE started_at > ended_at;
-- 43 values with the start time > end time - all of which have ##### values in the 'ride_length' column.

-- c. Remove invalid 'ride_length' records in the '202411' table
DELETE FROM cyclistic-24-25.cyclistic_dataset.202411
WHERE started_at > ended_at;
-- 43 rows removed


# 2. Cast data type in '202411' table as TIME (rather than STRING).

-- a. Add temporary column with the correct TIME data type
ALTER TABLE cyclistic-24-25.cyclistic_dataset.202411
ADD COLUMN ride_length_time TIME;

-- b. Cast values from original STRING data type column to new TIME data type column
UPDATE cyclistic-24-25.cyclistic_dataset.202411
SET ride_length_time = CAST(ride_length AS TIME)
WHERE TRUE;

-- c. Delete original STRING data type column
ALTER TABLE cyclistic-24-25.cyclistic_dataset.202411
DROP COLUMN ride_length;

-- d. Rename the new TIME data type column to the original 'ride_length' column name.
ALTER TABLE cyclistic-24-25.cyclistic_dataset.202411
RENAME COLUMN ride_length_time TO ride_length;


# 3. Ensure column order of '202411' table is consistent to match the other tables, and then merge all 12 tables into 1 table.

-- a. Create new table with correct column order
CREATE TABLE IF NOT EXISTS cyclistic-24-25.cyclistic_dataset.202411_1 AS
SELECT 
      ride_id, 
      rideable_type, 
      started_at,
      ended_at,
      ride_length,
      day_of_week,
      start_station_name,
      start_station_id, 
      end_station_name,
      end_station_id,
      start_lat,
      start_lng,
      end_lat,
      end_lng,
      member_casual
FROM cyclistic-24-25.cyclistic_dataset.202411;

-- b. Remove original '202411' table
DROP TABLE cyclistic-24-25.cyclistic_dataset.202411;

-- c. Merge all 12 files into 1 table
CREATE TABLE IF NOT EXISTS cyclistic-24-25.cyclistic_dataset.bikes_12months AS 
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202406
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202407
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202408
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202409
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202410
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202411_1
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202412
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202501
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202502
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202503
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202504
      UNION ALL
      SELECT *
      FROM cyclistic-24-25.cyclistic_dataset.202505;


# 5. Verify that the total number of rows matches the merged table’s row count of 5,628,804.
SELECT 
      (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202406) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202407) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202408) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202409) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202410) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202411_1) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202412) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202501) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202502) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202503) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202504) 
      + (SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.202505); 

SELECT COUNT(*) FROM cyclistic-24-25.cyclistic_dataset.bikes_12months;


# 6. Create backup copy of merged table
CREATE TABLE IF NOT EXISTS cyclistic-24-25.cyclistic_dataset.copy_bikes_12months
CLONE cyclistic-24-25.cyclistic_dataset.bikes_12months;



##### DATA CLEANING & MANIPULATION #####

# Identify Outliers, Unexpected Values, and Duplicates

# 1. Check to ensure that lengths of 'ride_id' are consistent.
SELECT 
      LENGTH(ride_id) AS num_of_characters, COUNT(*) AS count
FROM 
      cyclistic-24-25.cyclistic_dataset.bikes_12months
GROUP BY 
      LENGTH(ride_id);
-- All 'ride_id' values are exactly 16 characters


# 2. Check that the 'ride_id' values are unique with no duplicates
SELECT 
      COUNT(DISTINCT ride_id) AS num_of_distinct_rideid,
      COUNT(ride_id) AS num_of_rideid
FROM 
      cyclistic-24-25.cyclistic_dataset.bikes_12months;
-- The number of unique ride_id's matches the number of observations, so there are no duplicated ‘ride_id’ data and each string is unique.


# 3. Check for unexpected values in the 'rideable_type' column.
SELECT
      rideable_type,
      COUNT(*) AS number_of_trips
FROM 
      cyclistic-24-25.cyclistic_dataset.bikes_12months
GROUP BY 
      rideable_type;
-- We see that there are 2 different bike types (classic and electric), however the "electric_scooter" value should be removed as we are focused on bicycle trip data for this analysis.


# 4. Remove trips with the ride type of "electric_scooter".
DELETE FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
WHERE rideable_type = 'electric_scooter';


# 5. Add a 'ride_length_minutes' column to represent the ride duration in minutes, using a NUMERIC data type to preserve any decimal values produced from the calculation.
ALTER TABLE cyclistic-24-25.cyclistic_dataset.bikes_12months
ADD COLUMN ride_length_minutes NUMERIC;
 
UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET ride_length_minutes = CAST (TIMESTAMP_DIFF(ended_at, started_at, SECOND) AS NUMERIC) / 60.0
WHERE true;


# 6. Remove unexpected values under 1 minute in the 'ride_length' or 'ride_length_minutes' fields. 
      # Such unusually short ride durations often suggest either an accidental start or a user re-docking the bike to ensure it was secure.
DELETE FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
WHERE ride_length < '00:01:00' OR ride_length_minutes < 1.00;


# 7. Remove unexpected values over 24 hours in the `ride_length` or `ride_length_minutes` columns.
      # The company considers this to represent a lost or stolen bike - rather than a single legitimate trip.
DELETE FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
WHERE ride_length > '23:59:59' OR ride_length_minutes > 1440.00;


# 8. Calculate the upper and lower bounds using the interquartile range (IQR) method to identify potential outliers in the 'ride_length_minutes' column.
SELECT
      q1 - 1.5 * (q3 - q1) AS lower_bound,
      q3 + 1.5 * (q3 - q1) AS upper_bound
FROM (
      SELECT DISTINCT
            PERCENTILE_CONT(ride_length_minutes, 0.25) OVER () AS q1,
            PERCENTILE_CONT(ride_length_minutes, 0.75) OVER () AS q3
      FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
);
-- Lower bound is approximately -11.35 and upper bound is about 34.17.


# 9. Investigate the potential outliers in the `ride_length_minutes` column that fall outside these bounds.
SELECT
  *
FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
CROSS JOIN (
  SELECT
    q1 - 1.5 * (q3 - q1) AS lower_bound,
    q3 + 1.5 * (q3 - q1) AS upper_bound
  FROM (
    SELECT DISTINCT
      PERCENTILE_CONT(ride_length_minutes, 0.25) OVER () AS q1,
      PERCENTILE_CONT(ride_length_minutes, 0.75) OVER () AS q3
    FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
  )
)
WHERE
  ride_length_minutes < lower_bound
  OR ride_length_minutes > upper_bound
ORDER BY 
      ride_length, 
      ride_length_minutes;
-- We will keep these outliers, as there is no way to verify their accuracy with the information currently available.


# 10. Check for unexpected values in the 'day_of_week' column.
SELECT
      day_of_week,
      COUNT(*)
FROM 
      cyclistic-24-25.cyclistic_dataset.bikes_12months
GROUP BY 
      day_of_week
ORDER BY
      day_of_week;
-- The query results show the values 1, 2, 3, 4, 5, 6, and 7 - which is accurate as each number signifies the corresponding numerical day of the week.


# 11. Check for station ID's which are mapped to more than one station name.

-- a. Identify `start_station_id`'s associated with more than one 'start_station_name'.
SELECT
  start_station_id,
  start_station_name,
  COUNT(*) AS name_count
FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
GROUP BY start_station_id, start_station_name
QUALIFY COUNT(DISTINCT start_station_name) OVER (PARTITION BY start_station_id) > 1
ORDER BY start_station_id, name_count DESC;

-- b. Identify 'end_station_id''s associated with more than one 'end_station_name'.
SELECT
  end_station_id,
  end_station_name,
  COUNT(*) AS name_count
FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
GROUP BY end_station_id, end_station_name
QUALIFY COUNT(DISTINCT end_station_name) OVER (PARTITION BY end_station_id) > 1
ORDER BY end_station_id, name_count DESC;

-- After examining the records, it appears that some of the duplicates are due to misspellings or stray characters. 
-- However, I will leave these station names unchanged except for correcting these errors, as doing so could remove valid information.


# 12. Clean and standardize start and end station names by removing trailing asterisks, replacing "and" with "&", correcting misspellings and formatting issues.

-- a. Remove trailing asterisk in 'start_station_name' field.
UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET start_station_name = TRIM(start_station_name, '*')
WHERE start_station_name LIKE '%*';

-- b. Change "and" to "&" for any 'start_station_name' values.
UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET start_station_name = REPLACE(start_station_name, ' and ', ' & ')
WHERE start_station_name LIKE '% and %';

-- c. Standardize the 'start_station_name' entries with misspellings, incorrect street suffixes, or extra characters.
UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET start_station_name = CASE
    WHEN start_station_name = 'Lowell Ave & Armitage' THEN 'Lowell Ave & Armitage Ave'
    WHEN start_station_name = 'Ada St & 113th St' THEN 'Ada St & 113th Place'
    WHEN start_station_name = 'Rockwell St & Archer Ave\t' THEN 'Rockwell St & Archer Ave'
    WHEN start_station_name = 'Oketo Ave & Addison' THEN 'Oketo Ave & Addison St'
    WHEN start_station_name = 'Kedzie Ave & 38th Pl' THEN 'Kedzie Ave & 38th St'
    WHEN start_station_name = 'Damen Ave & Walnut (Lake) St' THEN 'Damen Ave & Lake St'
    WHEN start_station_name = 'Public Rack - Hamlin Ave & Chicago Ave' THEN 'Kedzie Ave & 38th St'
    WHEN start_station_name = 'Franklin St & Adams St (Temp)' THEN 'Franklin St & Adams St'
    ELSE start_station_name
  END
WHERE start_station_name IN (
      'Lowell Ave & Armitage',
      'Ada St & 113th St',
      'Rockwell St & Archer Ave\t',
      'Oketo Ave & Addison',
      'Kedzie Ave & 38th Pl',
      'Damen Ave & Walnut (Lake) St',
      'Public Rack - Hamlin Ave & Chicago Ave',
      'Franklin St & Adams St (Temp)'
);

-- d. Remove trailing asterisk in 'end_station_name' field.
UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET end_station_name = TRIM(end_station_name, '*')
WHERE end_station_name LIKE '%*';

-- e. Change "and" to "&" for any 'end_station_name' values.
UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET end_station_name = REPLACE(start_station_name, ' and ', ' & ')
WHERE end_station_name LIKE '% and %';

-- f. Standardize the `end_station_name` entries with misspellings or extra characters.
UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET end_station_name = CASE
    WHEN end_station_name = 'Lowell Ave & Armitage' THEN 'Lowell Ave & Armitage Ave'
    WHEN end_station_name = 'Ada St & 113th St' THEN 'Ada St & 113th Place'
    WHEN end_station_name = 'Rockwell St & Archer Ave\t' THEN 'Rockwell St & Archer Ave'
    WHEN end_station_name = 'Kildare Ave & 85th St (Kostner Ave & 87th St TEMPORARY)' THEN 'Kildare Ave & 85th St'
    WHEN end_station_name = 'Kedzie Ave & 38th Pl' THEN 'Kedzie Ave & 38th St'
    ELSE end_station_name
  END
WHERE start_station_name IN (
      'Lowell Ave & Armitage',
      'Ada St & 113th St',
      'Rockwell St & Archer Ave\t',
      'Kildare Ave & 85th St (Kostner Ave & 87th St TEMPORARY)'
      'Kedzie Ave & 38th Pl'
);

# I chose not to modify cases where multiple station IDs are associated with the same station name, since station IDs are not the focus of the analysis.


# 13. Remove records with 'end_station_id' of "Hubbard Bike-checking (LBS-WH-TEST)", as this seems to represent a test/service trip since it does not match the typical numeric or alphanumeric values for the station ID.
DELETE FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
WHERE end_station_id = "Hubbard Bike-checking (LBS-WH-TEST)";


# 14. Check for unexpected values in the 'member_casual' column.

SELECT
      DISTINCT(member_casual)
FROM 
      cyclistic-24-25.cyclistic_dataset.bikes_12months;
-- The query results show that there are only 2 distinct values of "member" and "casual".


# 15. Remove any records with invalid latitude and longitude values.

DELETE FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
WHERE start_lat NOT BETWEEN -90 AND 90
   OR start_lng NOT BETWEEN -180 AND 180
   OR end_lat NOT BETWEEN -90 AND 90
   OR end_lng NOT BETWEEN -180 AND 180;



##### ADDRESS NULL VALUES #####

# 1. Check the number of null values.
SELECT
      COUNT(*) - COUNT(ride_id) AS ride_id_count, 
      COUNT(*) - COUNT(rideable_type) AS rideable_type_count, 
      COUNT(*) - COUNT(day_of_week) AS day_of_week_count,
      COUNT(*) - COUNT(started_at) AS started_at_count, 
      COUNT(*) - COUNT(ended_at) AS ended_at_count, 
      COUNT(*) - COUNT(ride_length) AS ride_length_count,
      COUNT(*) - COUNT(start_station_name) AS start_station_name_count,
      COUNT(*) - COUNT(start_station_id) AS start_station_id_count,
      COUNT(*) - COUNT(end_station_name) AS end_station_name_count,
      COUNT(*) - COUNT(end_station_id) AS end_station_id_count,
      COUNT(*) - COUNT(start_lat) AS start_lat_count, 
      COUNT(*) - COUNT(start_lng) AS start_lng_count, 
      COUNT(*) - COUNT(end_lat) AS end_lat_count, 
      COUNT(*) - COUNT(end_lng) AS end_lng_count,
      COUNT(*) - COUNT(member_casual) AS member_casual_count
FROM 
      cyclistic-24-25.cyclistic_dataset.bikes_12months;
-- There are 943,845 null records in the 'start_station_name' and 'start_station_id' columns, 945,840 null records in the 'end_station_name' column, 945,456 null records'end_station_id' columns, and 34 null records in the 'end_lat' and 'end_lng' columns - which is quite a significant amount of null values.


# 2. Inspect null values in end latitude & longitude columns
SELECT *
FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
WHERE 
      end_lat IS NULL OR
      end_lng IS NULL;
-- Upon review, it seems that all 34 null records in the 'end_lat' and 'end_lng' columns are associated with classic bikes and also lack values for 'end_station_name' and 'end_station_id'. Since classic bikes must be returned to a docking station to complete a ride, these missing values likely indicate that the bikes were lost, stolen, or not properly docked. As these records represent only 0.00063% of the total data, removing them will not significantly impact the analysis or skew the representation of classic bikes.


# 3. Delete records with no end station name, ID, or coordinates
DELETE FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
WHERE 
      end_station_name IS NULL AND
      end_station_id IS NULL AND
      end_lat IS NULL AND
      end_lng IS NULL;
-- 34 records were removed. 


# 4. Verify if every missing station name and id has associated coordinates. This query shows all records where the `station_name` or `station_id` is null and any coordinate is also null. 
SELECT *
FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
WHERE 
      (start_station_name IS NULL OR start_station_id IS NULL)
      AND (
            start_lat IS NULL
            OR start_lng IS NULL
            OR end_lat IS NULL
            OR end_lng IS NULL);

SELECT *
FROM cyclistic-24-25.cyclistic_dataset.bikes_12months
WHERE 
      (end_station_name IS NULL OR end_station_id IS NULL)
      AND (
            start_lat IS NULL
            OR start_lng IS NULL
            OR end_lat IS NULL
            OR end_lng IS NULL);

-- The queries return no values, indicating that all records with missing station names or ID's still have corresponding coordinate values. Thus, we will retain the records with null values in the `start_station_name`, `start_station_id`, `end_station_name`, and `end_station_id` columns, as they still include the necessary latitude and longitude data for analysis. 


# 5. Replace null values in these four columns with "No ID" or "No station".
UPDATE 
      cyclistic-24-25.cyclistic_dataset.bikes_12months
SET 
      start_station_name = 'No station'
WHERE start_station_name IS NULL;

UPDATE 
      cyclistic-24-25.cyclistic_dataset.bikes_12months
SET 
      start_station_id = 'No ID'
WHERE start_station_id IS NULL;

UPDATE 
      cyclistic-24-25.cyclistic_dataset.bikes_12months
SET 
      end_station_name = 'No station'
WHERE end_station_name IS NULL;

UPDATE 
      cyclistic-24-25.cyclistic_dataset.bikes_12months
SET 
      end_station_id = 'No ID'
WHERE end_station_id IS NULL;



##### TRANSFORM & EXPORT FOR ANALYSIS #####

# 1. Convert 'day_of_week' from number to name of day
-- a. Cast data type as STRING (rather than INT)
ALTER TABLE cyclistic-24-25.cyclistic_dataset.bikes_12months
ADD COLUMN day_of_week_name STRING;

-- b. Set 'day_of_week_name' values by using CASE statement
UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET day_of_week_name = CASE 
      WHEN day_of_week = 1 THEN 'Sunday'
      WHEN day_of_week = 2 THEN 'Monday'
      WHEN day_of_week = 3 THEN 'Tuesday'
      WHEN day_of_week = 4 THEN 'Wednesday'
      WHEN day_of_week = 5 THEN 'Thursday'
      WHEN day_of_week = 6 THEN 'Friday'
      WHEN day_of_week = 7 THEN 'Saturday'
      END
WHERE true;

-- c. Drop initial day_of_week column
ALTER TABLE cyclistic-24-25.cyclistic_dataset.bikes_12months
DROP COLUMN day_of_week;

-- d. Rename the new day_of_week_name column to the original 'day_of_week' column name
ALTER TABLE cyclistic-24-25.cyclistic_dataset.bikes_12months
RENAME COLUMN day_of_week_name TO day_of_week;


# 2. Add a 'start_time' column by casting the time the ride started from 'started_at'.
ALTER TABLE cyclistic-24-25.cyclistic_dataset.bikes_12months
ADD COLUMN start_time TIME;

UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET start_time = CAST(started_at AS TIME)
WHERE true;


# 3. Add a 'start_date' column by casting the date the ride started from `started_at`
ALTER TABLE cyclistic-24-25.cyclistic_dataset.bikes_12months
ADD COLUMN start_date DATE;

UPDATE cyclistic-24-25.cyclistic_dataset.bikes_12months
SET start_date = CAST(started_at AS DATE)
WHERE true;


# 4. Drop the `ride_length` column (formatted as hh:mm:ss), as the 'ride_length_minutes' field provides a more useful measure for analysis and visualization.
ALTER TABLE cyclistic-24-25.cyclistic_dataset.bikes_12months
DROP COLUMN ride_length;


# 5. Retrieve all records from data, so it can be saved to export to Google Cloud Storage and then imported to Tableau for visualization.
SELECT *
FROM cyclistic-24-25.cyclistic_dataset.bikes_12months;
